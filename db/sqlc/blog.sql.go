// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: blog.sql

package db

import (
	"context"
	"time"
)

const countAllBlog = `-- name: CountAllBlog :one
SELECT COUNT(1) AS count
FROM blog
WHERE deleted IS FALSE
AND LOWER(title) LIKE '%' || LOWER($1) || '%'
LIMIT 1
`

func (q *Queries) CountAllBlog(ctx context.Context, lower string) (int64, error) {
	row := q.db.QueryRow(ctx, countAllBlog, lower)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllBlogWithTag = `-- name: CountAllBlogWithTag :one
SELECT COUNT(DISTINCT b.id) AS count
FROM blog b
LEFT JOIN blog_tag bt ON b.id = bt.blog_id AND bt.deleted IS FALSE
LEFT JOIN tag t ON bt.tag_id = t.id AND t.deleted IS FALSE
WHERE b.deleted IS FALSE
AND LOWER(b.title) LIKE '%' || LOWER($1) || '%'
AND LOWER(t.name) = LOWER($2)
LIMIT 1
`

type CountAllBlogWithTagParams struct {
	Lower   string `json:"lower"`
	Lower_2 string `json:"lower_2"`
}

func (q *Queries) CountAllBlogWithTag(ctx context.Context, arg CountAllBlogWithTagParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAllBlogWithTag, arg.Lower, arg.Lower_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBlog = `-- name: CreateBlog :one
INSERT INTO blog
(title, content, image, url, created_at)
VALUES ($1, $2, $3, $4, NOW()::TIMESTAMPTZ)
RETURNING id, title, content, image, url, created_at, updated_at, deleted
`

type CreateBlogParams struct {
	Title   string `json:"title"`
	Content string `json:"content"`
	Image   string `json:"image"`
	Url     string `json:"url"`
}

func (q *Queries) CreateBlog(ctx context.Context, arg CreateBlogParams) (Blog, error) {
	row := q.db.QueryRow(ctx, createBlog,
		arg.Title,
		arg.Content,
		arg.Image,
		arg.Url,
	)
	var i Blog
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Image,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deleted,
	)
	return i, err
}

const deleteBlog = `-- name: DeleteBlog :exec
UPDATE blog
SET updated_at = NOW()::TIMESTAMPTZ,
deleted = TRUE
WHERE deleted IS FALSE
AND id = $1
`

func (q *Queries) DeleteBlog(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteBlog, id)
	return err
}

const getAllBlog = `-- name: GetAllBlog :many
SELECT
id, title, content, image, url, created_at, updated_at
FROM blog
WHERE deleted IS FALSE
AND LOWER(title) LIKE '%' || LOWER($1) || '%'
ORDER BY created_at DESC
OFFSET $2
LIMIT $3
`

type GetAllBlogParams struct {
	Lower  string `json:"lower"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

type GetAllBlogRow struct {
	ID        int64     `json:"id"`
	Title     string    `json:"title"`
	Content   string    `json:"content"`
	Image     string    `json:"image"`
	Url       string    `json:"url"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) GetAllBlog(ctx context.Context, arg GetAllBlogParams) ([]GetAllBlogRow, error) {
	rows, err := q.db.Query(ctx, getAllBlog, arg.Lower, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllBlogRow{}
	for rows.Next() {
		var i GetAllBlogRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Image,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBlogWithTag = `-- name: GetAllBlogWithTag :many
SELECT DISTINCT
b.id, b.title, b.content, b.image, b.url, b.created_at, b.updated_at
FROM blog b
LEFT JOIN blog_tag bt ON b.id = bt.blog_id AND bt.deleted IS FALSE
LEFT JOIN tag t ON bt.tag_id = t.id AND t.deleted IS FALSE
WHERE b.deleted IS FALSE
AND LOWER(b.title) LIKE '%' || LOWER($1) || '%'
AND LOWER(t.name) = LOWER($2)
ORDER BY b.created_at DESC
OFFSET $3
LIMIT $4
`

type GetAllBlogWithTagParams struct {
	Lower   string `json:"lower"`
	Lower_2 string `json:"lower_2"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
}

type GetAllBlogWithTagRow struct {
	ID        int64     `json:"id"`
	Title     string    `json:"title"`
	Content   string    `json:"content"`
	Image     string    `json:"image"`
	Url       string    `json:"url"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) GetAllBlogWithTag(ctx context.Context, arg GetAllBlogWithTagParams) ([]GetAllBlogWithTagRow, error) {
	rows, err := q.db.Query(ctx, getAllBlogWithTag,
		arg.Lower,
		arg.Lower_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllBlogWithTagRow{}
	for rows.Next() {
		var i GetAllBlogWithTagRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Image,
			&i.Url,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlogById = `-- name: GetBlogById :one
SELECT
id, title, content, image, url, created_at, updated_at
FROM blog
WHERE deleted IS FALSE
AND id = $1
LIMIT 1
`

type GetBlogByIdRow struct {
	ID        int64     `json:"id"`
	Title     string    `json:"title"`
	Content   string    `json:"content"`
	Image     string    `json:"image"`
	Url       string    `json:"url"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) GetBlogById(ctx context.Context, id int64) (GetBlogByIdRow, error) {
	row := q.db.QueryRow(ctx, getBlogById, id)
	var i GetBlogByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Image,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBlogByUrl = `-- name: GetBlogByUrl :one
SELECT
id, title, content, image, url, created_at, updated_at
FROM blog
WHERE deleted IS FALSE
AND url = $1
LIMIT 1
`

type GetBlogByUrlRow struct {
	ID        int64     `json:"id"`
	Title     string    `json:"title"`
	Content   string    `json:"content"`
	Image     string    `json:"image"`
	Url       string    `json:"url"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) GetBlogByUrl(ctx context.Context, url string) (GetBlogByUrlRow, error) {
	row := q.db.QueryRow(ctx, getBlogByUrl, url)
	var i GetBlogByUrlRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Image,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBlog = `-- name: UpdateBlog :exec
UPDATE blog
SET title = $2,
content = $3,
image = $4,
url = $5,
updated_at = NOW()::TIMESTAMPTZ
WHERE deleted IS FALSE
AND id = $1
`

type UpdateBlogParams struct {
	ID      int64  `json:"id"`
	Title   string `json:"title"`
	Content string `json:"content"`
	Image   string `json:"image"`
	Url     string `json:"url"`
}

func (q *Queries) UpdateBlog(ctx context.Context, arg UpdateBlogParams) error {
	_, err := q.db.Exec(ctx, updateBlog,
		arg.ID,
		arg.Title,
		arg.Content,
		arg.Image,
		arg.Url,
	)
	return err
}
